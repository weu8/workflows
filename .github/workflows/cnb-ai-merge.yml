name: cnb-ai-merge (reusable, final)

on:
  workflow_call:
    inputs:
      upstream_repo:        # 必填：上游仓 HTTPS，如 https://github.com/juanfont/headscale
        required: true
        type: string
      cnb_repo_url:         # 必填：CNB 仓 HTTPS，如 https://cnb.cool/g.h/headplane(.git)
        required: true
        type: string
      delete_ai_branch:     # 可选：推送成功后删除 GitHub 远端 ai/* 分支
        required: false
        type: boolean
        default: false
    secrets:
      CNB_GH_TOKEN:         # 必填：对 CNB 有写入权限的令牌
        required: true

permissions:
  contents: write

# 防并发“拔河”：同一目标仓/分支只保留最后一次，自动取消在途
concurrency:
  group: cnb-ai-merge-${{ inputs.cnb_repo_url }}-Github-AI
  cancel-in-progress: true

jobs:
  merge-and-push:
    runs-on: ubuntu-latest
    steps:
      # 1) 拉取当前触发分支（通常是 ai/*）
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0   # 保留完整历史，便于 merge

      # 2) 统一 Git 身份 & 网络稳态
      - name: Setup Git identity
        run: |
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config --global http.lowSpeedLimit 1000
          git config --global http.lowSpeedTime 60

      # 3) 记录当前 ai/* 分支名（由本次触发带来）
      - name: Detect AI branch
        id: detect
        run: |
          REF="${GITHUB_REF#refs/heads/}"
          echo "ai_branch=${REF}" >> "$GITHUB_OUTPUT"

      # 4) 配置 upstream 与 cnb 两个远端（cnb 用带 token 的 URL）
      - name: Prepare remotes
        env:
          CNB_GH_TOKEN: ${{ secrets.CNB_GH_TOKEN }}
        run: |
          set -e
          # upstream（上游 GitHub 仓）
          git remote add upstream "${{ inputs.upstream_repo }}" || true
          git fetch upstream --prune

          # cnb（目标 CNB 仓），用别名“cnb”统一推送地址
          RAW="${{ inputs.cnb_repo_url }}"
          case "$RAW" in
            https://*) : ;;
            *) echo "ERROR: cnb_repo_url 必须以 https:// 开头" >&2; exit 1 ;;
          esac
          [[ "$RAW" =~ \.git$ ]] || RAW="${RAW}.git"
          CNB_URL="${RAW/https:\/\//https:\/\/cnb:${CNB_GH_TOKEN}@}"
          git remote add cnb "$CNB_URL" 2>/dev/null || git remote set-url cnb "$CNB_URL"

          # 轻度重试，抗网络抖动
          for i in 1 2 3; do git fetch cnb --prune && break || { echo "fetch cnb retry $i/3" >&2; sleep 5; }; done

      # 5) 选择基线（保持你原版语义：优先 cnb/main，否则 upstream/main）
      - name: Start from CNB main or upstream main
        run: |
          set -e
          if git ls-remote --heads cnb main | grep -q main; then
            git checkout -b cnbr-main cnb/main
          else
            git checkout -b cnbr-main upstream/main
          fi

      # 6) 合并“上游轨”再合并本次 AI（保持你原版语义）
      - name: Merge CNB upstream then AI branch
        run: |
          set -e
          # 若 CNB 维护了一个 upstream 分支，则先合它；否则直接合上游 upstream/main
          if git ls-remote --heads cnb upstream | grep -q upstream; then
            git pull --no-edit cnb upstream
          else
            git pull --no-edit upstream main
          fi
          # 合并触发的 ai/* 本地分支，保留一次“AI 投递”的合并节点
          # 解决合并冲突：优先使用 AI 分支的内容
          git merge --no-ff --no-edit -X theirs "${{ steps.detect.outputs.ai_branch }}" || {
            echo "::warning::merge had conflicts, auto-resolving by preferring AI branch"
            # 如果合并仍然失败，自动解决冲突，优先使用 AI 侧的内容
            git checkout --theirs .
            git add -A
            git commit -m "chore(ci): auto-resolve conflicts, prefer AI branch"
          }

      # 7) 推前打“只增不改”的快照 tag（用于回溯/对比；不污染分支列表，可选但推荐）
      - name: Tag snapshot (immutable)
        id: snap
        run: |
          set -e
          RUN_TS="$(date -u +%Y%m%dT%H%M%SZ)"
          SHORT="$(git rev-parse --short=12 HEAD)"
          TAG="ai-snap/${RUN_TS}-${SHORT}"
          git tag -a "$TAG" -m "AI snapshot from ${GITHUB_REPOSITORY}@${GITHUB_REF}"
          git push cnb "refs/tags/${TAG}"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"

      # 8) 推送到 CNB/Github-AI：强覆盖，但用 --force-with-lease 带“安全闩”
      - name: Push to CNB Github-AI (force-with-lease)
        id: push_cnb
        run: |
          set -e
          NEW_HEAD="$(git rev-parse HEAD)"
          echo "new_head=${NEW_HEAD}" >> "$GITHUB_OUTPUT"
          for i in 1 2 3; do
            git push cnb HEAD:refs/heads/Github-AI --force-with-lease && break || {
              echo "push retry $i/3 ..." >&2; sleep 5;
            }
          done

      # 9) 远端校验（确保我们刚推上的 HEAD 一致）
      - name: Verify CNB/Github-AI advanced
        id: verify
        run: |
          set -e
          REMOTE_SHA="$(git ls-remote cnb refs/heads/Github-AI | awk '{print $1}')"
          echo "cnb_head=${REMOTE_SHA}" >> "$GITHUB_OUTPUT"
          test "$REMOTE_SHA" = "${{ steps.push_cnb.outputs.new_head }}"

      # 10) 可选：删除 GitHub 远端 ai/*（仅在本次成功后）
#      - name: Delete GitHub ai/* branch (remote)
#        if: ${{ inputs.delete_ai_branch == true && startsWith(github.ref, 'refs/heads/ai/') && success() }}
#        run: |
#          git push origin :${{ steps.detect.outputs.ai_branch }}
